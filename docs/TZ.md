# ТЕХНИЧЕСКОЕ ЗАДАНИЕ (ТЗ) v0.2
Проект: SamurAI — Telegram-бот «ИИ-нумеролог»
Формат: MVP с «заглушками» по наполнению тарифов и без интеграции платежной системы
Добавлено в v0.2: поддержка двух LLM-провайдеров (OpenAI + Gemini) с переключателем в config.php
Дата: 2026-01-30
Часовой пояс статистики: GMT+3

=====================================================================
1) Цель и результат MVP
=====================================================================

Цель: запустить Telegram-бота, который собирает данные пользователя, формирует нумерологический отчёт (пока по заглушечным промптам), даёт возможность задать уточняющие вопросы по полученному результату, ведёт базу пользователей и историю переписки, предоставляет админ-функции (статистика, рассылка, экспорт).

MVP должен уметь:
1) /start → приветствие → 4 тарифа: 0 / 560 / 2190 / 5930.
2) Выбор тарифа → сбор анкеты пользователя (4 поля):
   - дата рождения (ДД.ММ.ГГГГ)
   - время рождения (ЧЧ:ММ, допускается неизвестно — см. TODO)
   - ФИО при рождении (текст)
   - место рождения (текст)
3) Генерация отчёта через LLM API (один запрос) по системному промпту тарифа + данным анкеты.
   - На MVP допускается одинаковый промпт на все тарифы (заглушка), но архитектура обязана поддерживать разные.
   - LLM-провайдер должен быть переключаемым: OpenAI или Gemini.
4) Выдача результата пользователю:
   - текстом в Telegram
   - кнопка «Скачать PDF» (красивый PDF отчёта)
5) Follow-up: пользователь может задать несколько уточняющих вопросов по отчёту (включая тариф 0).
   - смысл и ограничения follow-up по тарифам будут уточнены после наполнения тарифов (TODO Коля), поэтому в MVP всё параметризуемо.
6) База пользователей:
   - хранение пользователей
   - классификация купил/не купил (пока без платежки — через админ-команду mark_paid)
7) Админка:
   - поддержка нескольких админов
   - статистика по дням (GMT+3) + выгрузка статистики в CSV
   - рассылка по сегментам (купил/не купил)
   - экспорт базы (JSON) и экспорт отчёта (PDF)
8) Хранение истории переписки:
   - хранить всю переписку бессрочно: входящие/исходящие сообщения, события, кнопки, отчёты, follow-up.

Платёжка:
- Не реализуется в MVP, интегрируется позже (TODO Вадим).
- Архитектурно должны быть точки расширения, чтобы подключить платежку без переработки ядра.

=====================================================================
2) Роли и доступы
=====================================================================

2.1 Пользователь (обычный)
- проходит /start
- выбирает тариф
- заполняет анкету
- получает отчёт (текст + PDF)
- задаёт follow-up вопросы по отчёту
- может повторно запросить новый отчёт (начиная с выбора тарифа)

2.2 Администратор (несколько)
- управляет списком админов
- смотрит статистику (по дням, GMT+3)
- выгружает статистику в CSV
- делает рассылки по сегментам
- выгружает базу в JSON (включая историю сообщений и покупки)
- (временно) помечает пользователя «купил» и создаёт запись покупки (до платежки)

Доступ к админ-командам только тем, кто находится в таблице admins.

=====================================================================
3) Пользовательский сценарий и UX
=====================================================================

3.1 Команда /start
1) Бот сохраняет/обновляет данные пользователя в БД:
   - tg_id (обязательно)
   - username (если есть)
   - first_name/last_name (если есть)
   - created_at (если новый)
   - last_seen_at (всегда обновляется)
2) Бот отправляет приветственное сообщение (текст предоставит команда, пока заглушка).
3) Бот показывает 4 кнопки тарифов:
   [Тариф 0] [560] [2190] [5930]
   Дополнительные кнопки (опционально): «Как это работает», «Задать вопрос» (пока не обязательно).

3.2 Выбор тарифа → сбор анкеты
После нажатия кнопки тарифа бот:
1) Запоминает выбранный тариф как текущий контекст пользователя.
2) Запускает сбор анкеты по шагам (последовательно):
   Шаг 1: «Введите дату рождения (ДД.ММ.ГГГГ)»
   Шаг 2: «Введите время рождения (ЧЧ:ММ)» (см. TODO про «не знаю»)
   Шаг 3: «Введите ФИО при рождении»
   Шаг 4: «Введите место рождения (город/страна)»
3) После заполнения:
   - сохраняет профиль (анкета) как текущий
   - запускает процесс генерации отчёта

3.3 Генерация отчёта
1) Бот формирует запрос к LLM:
   - system_prompt_report для выбранного тарифа
   - user_prompt_template_report для выбранного тарифа
   - данные анкеты
2) Делается 1 основной запрос. Ответ сохраняется в БД и возвращается пользователю.
3) Провайдер LLM выбирается в config.php (см. раздел 4).

3.4 Выдача отчёта и дальнейшие действия
После отправки отчёта пользователю бот показывает кнопки:
- «Скачать PDF»
- «Задать вопрос по результату»
- «Новый расчёт» (возврат к выбору тарифа)

3.5 Follow-up вопросы по отчёту (включая тариф 0)
1) После выдачи отчёта создаётся ReportSession (сессия отчёта).
2) Любое сообщение пользователя после отчёта в пределах активной сессии считается follow-up вопросом.
3) Для каждого follow-up запроса бот вызывает LLM с контекстом:
   - анкета пользователя
   - текст отчёта (report_text)
   - история follow-up вопросов/ответов в рамках report_id
   - system_prompt_followup тарифа
4) Ответ отправляется пользователю и сохраняется в историю переписки.
5) Ограничения follow-up:
   - followup_limit (кол-во вопросов) — параметр политики тарифа (TEMP)
   - followup_window_hours (окно времени) — параметр политики тарифа (TEMP)
   - followup_rules (что можно/нельзя) — параметр политики тарифа (TEMP)
   На MVP допускается TEMP-дефолт для всех тарифов, позже Коля уточнит.

=====================================================================
4) LLM слой: поддержка OpenAI + Gemini с переключателем в config.php
=====================================================================

4.1 Общий принцип
В кодовой базе должен быть единый интерфейс LLMProvider, который скрывает различия OpenAI и Gemini.
Бизнес-логика (анкета → отчёт → follow-up) НЕ должна зависеть от конкретного API.

Вызов LLM везде осуществляется через одну функцию/метод:
- generateReport(tariffPolicy, profileData) -> LlmResult
- answerFollowup(tariffPolicy, profileData, reportText, followupHistory, userQuestion) -> LlmResult

4.2 Переключатель провайдера
Для упрощения переключатель хранится в config.php.

Пример требований к config.php (структура может отличаться, но смысл обязателен):

- LLM_PROVIDER = 'openai' | 'gemini'
- OPENAI_API_KEY
- OPENAI_MODEL_REPORT (например: gpt-4.1-mini / gpt-4o-mini / и т.п.)
- OPENAI_MODEL_FOLLOWUP (может совпадать)
- GEMINI_API_KEY
- GEMINI_MODEL_REPORT (например: gemini-1.5-pro / gemini-1.5-flash / и т.п.)
- GEMINI_MODEL_FOLLOWUP (может совпадать)
- LLM_TEMPERATURE (общая настройка)
- LLM_MAX_OUTPUT_TOKENS (общая настройка)
- LLM_TIMEOUT_SECONDS

Важно:
- ключи не коммитить в репозиторий; хранить через env/secret-менеджер или закрытый config.php вне VCS (на усмотрение команды).
- значения моделей допускаются как заглушки и уточняются на внедрении.

4.3 Нормализованный формат результата (одинаковый для обоих провайдеров)
Для дальнейшей обработки (PDF/логирование/экспорт) результат LLM приводится к общей структуре:

LlmResult:
- provider: 'openai'|'gemini'
- model: строка
- raw_text: строка (если есть)
- parsed_json: объект|null (если модель вернула структурированный JSON)
- text: строка (итоговый текст для Telegram)
- pdf_blocks: массив блоков (для PDF) или null
- disclaimer: строка или null
- usage: {prompt_tokens, output_tokens, total_tokens} или null (если провайдер не отдает)
- latency_ms: число
- request_id: строка|null (если доступно)

4.4 Требование к формату ответа модели (для стабильного PDF)
Модель должна возвращать:
A) text — итоговый текст отчёта для Telegram
B) pdf_blocks — структурированные блоки для PDF (заголовки/подразделы/списки)

Рекомендуемый вариант:
- Запросить у модели структурированный JSON по схеме:
  {
    "text": "...",
    "pdf_blocks": [
      {"type":"h1","value":"..."},
      {"type":"p","value":"..."},
      {"type":"ul","items":["...","..."]},
      ...
    ],
    "disclaimer": "..."
  }

Если JSON невалидный:
- выполнить 1 попытку repair-запроса (через того же провайдера) «исправь JSON, не меняя смысла»
- если повторно невалидный → формировать PDF из plain text (text/raw_text).

4.5 Ошибки/ретраи/фолбэки
- При ошибке провайдера: 1 ретрай.
- Если ретрай не помог:
  - ответ пользователю: «Техническая ошибка, попробуйте позже»
  - лог админу (опционально)
- Фолбэк на другого провайдера (openai↔gemini) НЕ обязателен в MVP, но допускается как расширение.
  Если реализуется — должен быть отдельный флаг в config.php: LLM_FALLBACK_ENABLED (bool).

4.6 Логирование вызовов LLM
Для аналитики и отладки рекомендуется логировать:
- provider, model
- latency_ms
- наличие/валидность JSON
- ошибки
- usage (если доступно)
При этом НЕ хранить API-ключи и не логировать чувствительные данные сверх необходимого (см. раздел 9: хранение истории).

=====================================================================
5) Политики тарифов (заглушки на MVP)
=====================================================================

Для каждого тарифа хранится конфигурация (в БД или конфиг-файле). Предпочтительно БД.

Поля политики тарифа:
- tariff_id: 0 / 560 / 2190 / 5930
- title: строка (TEMP)
- system_prompt_report: текст (TEMP)
- user_prompt_template_report: текст (TEMP)
- system_prompt_followup: текст (TEMP)
- followup_limit: int (TEMP; позже задаст Коля)
- followup_window_hours: int или null (TEMP; null = бессрочно)
- followup_rules: текст (TEMP)
- output_format: "text+json" (рекомендуется)

TEMP-дефолты на MVP (можно изменить):
- followup_limit: 3 для всех тарифов
- followup_window_hours: null
- followup_rules: «Отвечай строго по содержанию отчёта. Если вопрос уводит в сторону — мягко возвращайся к отчёту.»

TODO (Коля): финальные промпты и правила по каждому тарифу.

=====================================================================
6) PDF отчёта (красивый)
=====================================================================

Кнопка «Скачать PDF»:
- генерирует PDF из pdf_blocks (приоритет)
- если pdf_blocks отсутствует → генерирует PDF из text

Требования к PDF:
- титульный блок:
  - ФИО при рождении
  - дата формирования отчёта
  - тариф
- структурированные заголовки и списки
- футер: номер страницы + «SamurAI»
- дисклеймер (текст задаётся в конфиге/политике)

PDF отправляется пользователю как файл Telegram.

=====================================================================
7) База пользователей и классификация «купил/не купил»
=====================================================================

Сегментация:
- bought = true, если есть хотя бы 1 покупка со статусом paid
- иначе not_bought

Платёжка не реализуется в MVP.
Временно вводится админ-команда mark_paid для имитации покупки:
- создаёт запись покупки (purchases)
- переводит пользователя в bought

=====================================================================
8) Админ-команды
=====================================================================

8.1 Управление админами
- /admin_add <tg_id|@username>
- /admin_del <tg_id|@username>
- /admins  (список админов)

8.2 Статистика (GMT+3)
- /stats today
- /stats yesterday
- /stats 7days
- /stats <YYYY-MM-DD> <YYYY-MM-DD>

Метрики (по дням):
- new_users
- started_form (начали анкету)
- finished_form (завершили анкету)
- reports_generated
- pdf_downloads
- followup_questions
- bought_users (по purchases paid / по mark_paid в MVP)
- revenue (TEMP=0 до платежки)

8.3 Экспорт статистики в CSV
- /export_stats <YYYY-MM-DD> <YYYY-MM-DD>
Результат: CSV-файл, отправляется админу в Telegram.

8.4 Рассылки по сегментам
- /broadcast bought <text>
- /broadcast not_bought <text>
- /broadcast all <text> (опционально)
- /broadcast_stop (желательно)

Требования:
- троттлинг/пакетная отправка
- лог доставки/ошибок для каждого пользователя
- хранить историю рассылок и результаты

8.5 Экспорт базы
- /export_users_json [segment]  → JSON бэкап базы:
  - users
  - profiles (включая версии)
  - purchases
  - messages/events
  - reports + report_sessions
  - llm_call_logs (если реализованы)
- /export_user_json <tg_id|@username> → JSON по одному пользователю (опционально)
- /export_user_pdf <tg_id|@username> → PDF-досье по одному пользователю (опционально)

8.6 Временная команда для покупок (до платежки)
- /mark_paid <tg_id|@username> <tariff> [comment]

=====================================================================
9) Требования к хранению истории переписки (бессрочно)
=====================================================================

Хранить бессрочно:
- все входящие сообщения пользователя (text + timestamp + метаданные)
- все исходящие сообщения бота (text + timestamp + тип: отчёт/follow-up/служебное)
- события: выбор тарифа, шаги анкеты, выдача отчёта, скачивание PDF, follow-up, рассылки, mark_paid
- payload кнопок (callback data)

Дополнение по LLM:
- допускается хранить «сырой ответ» LLM (raw_text) и «нормализованный результат» (parsed_json/text/pdf_blocks),
  но ключи и секреты не хранить.
- если команда решит ограничить хранение промптов/сырья — это настраивается флагом (TODO).

=====================================================================
10) Предлагаемая структура БД
=====================================================================

Рекомендуется Postgres (надёжнее при вечном хранении и экспортах).
Допускается SQLite на MVP (включить WAL), с планом миграции.

Таблицы (минимум):

1) users
- id (pk)
- tg_id (unique)
- username
- first_name
- last_name
- created_at
- last_seen_at
- last_tariff_selected
- is_bought (можно хранить как кэш, но истина в purchases)

2) user_profiles (анкеты, версии)
- id
- user_id
- birth_date
- birth_time (nullable)
- birth_name
- birth_place
- created_at
- is_current (bool)

3) purchases
- id
- user_id
- tariff_id
- amount
- currency
- status (paid/pending/canceled/refunded)
- provider (manual TEMP / позже реальный)
- provider_payment_id (nullable)
- created_at
- paid_at (nullable)
- comment (nullable)
- meta_json (nullable)

4) messages
- id
- user_id
- direction (in/out)
- message_type (text/report/followup/admin/system_event)
- text
- payload_json (nullable)
- created_at

5) reports
- id
- user_id
- tariff_id
- profile_id
- report_text
- report_json (nullable, для PDF)
- llm_provider (openai/gemini)
- llm_model (строка)
- created_at

6) report_sessions
- id
- report_id
- user_id
- is_followup_open
- followup_count
- created_at
- closed_at (nullable)

7) admins
- tg_id (unique)
- username (nullable)
- created_at
- added_by (nullable)

8) broadcasts
- id
- created_by_tg_id
- segment
- text
- status (running/completed/stopped/failed)
- created_at

9) broadcast_logs
- id
- broadcast_id
- user_id
- status (sent/failed)
- error (nullable)
- sent_at

10) tariff_policies
- tariff_id (pk)
- title
- system_prompt_report
- user_prompt_template_report
- system_prompt_followup
- followup_limit
- followup_window_hours
- followup_rules
- output_format
- updated_at

11) llm_call_logs (рекомендуется)
- id
- user_id (nullable)
- report_id (nullable)
- session_id (nullable)
- purpose ('report'|'followup'|'repair')
- provider ('openai'|'gemini')
- model
- request_id (nullable)
- latency_ms
- ok (bool)
- error_text (nullable)
- prompt_tokens (nullable)
- output_tokens (nullable)
- total_tokens (nullable)
- created_at

=====================================================================
11) Нефункциональные требования
=====================================================================

- Логирование ошибок (LLM/Telegram/PDF/экспорт) в файл + уведомление админу (опционально).
- Ограничение ретраев (не бесконечно).
- /start всегда «лечит» состояние и возвращает пользователя в нормальный поток.
- Часовой пояс статистики строго GMT+3.

=====================================================================
12) Платёжка (вне MVP, но предусмотреть интеграцию)
=====================================================================

В коде предусмотреть интерфейс провайдера платежей (абстракция):
- create_invoice(user_id, tariff_id, amount)
- handle_webhook(payload)
- verify_payment(provider_payment_id)

После успешного webhook:
- создать purchases(status=paid)
- запустить генерацию отчёта (или открыть доступ к генерации)

TODO (Вадим): выбрать платежную систему и требования (чеки/возвраты/сценарии).

=====================================================================
13) TODO / Вопросы на уточнение (для финального ТЗ)
=====================================================================

A) Наполнение тарифов (Коля)
- Финальные system_prompt_report / followup_prompt по каждому тарифу
- Различия тарифов по структуре/объёму/сферам/подаче
- Лимиты follow-up: кол-во вопросов, окно времени, правила (строго по отчёту или можно новые темы)

B) Платёжка (Вадим)
- провайдер, схема оплаты, webhook, статусы, возвраты
- нужна ли онлайн-касса/чеки

C) Анкета
- Что делать, если пользователь не знает время рождения? (кнопка «Не знаю»? поле optional?)
- Нужны ли дополнительные поля позже (пол, текущий город, запрос)

D) Экспорт
- Подтверждение: CSV = только статистика; JSON = полный бэкап базы; PDF = отчёт пользователю (+ опционально досье по одному пользователю)

E) Рассылки
- Нужна ли возможность «отписаться от рассылок»
- Нужны ли дополнительные сегменты кроме bought/not_bought

F) LLM
- Подтвердить список моделей по умолчанию (OpenAI + Gemini) для:
  - отчёта
  - follow-up
- Нужен ли fallback (автопереключение на другого провайдера при ошибке) или только ручной переключатель в config.php

=====================================================================
Конец документа
=====================================================================
